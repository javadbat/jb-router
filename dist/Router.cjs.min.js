'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ExceptionHandler = _interopDefault(require('jb-modules/ExceptionHandler/dist/ExceptionHandler.cjs.min'));
var React = _interopDefault(require('react'));
var ReactDOM = _interopDefault(require('react-dom'));

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Route =
function () {
  function Route(inputObj) {
    _classCallCheck(this, Route);
    _defineProperty(this, "url", null);
    _defineProperty(this, "name", null);
    _defineProperty(this, "settings", {});
    _defineProperty(this, "title", "");
    _defineProperty(this, "isRoot", void 0);
    _defineProperty(this, "params", void 0);
    _defineProperty(this, "regex", void 0);
    this.url = inputObj.url;
    this.name = inputObj.name;
    this.title = inputObj.title;
    this.settings = inputObj.settings;
    this.isRoot = this.url == "/" ? true : false;
    this.params = {};
    this.regex = new RegExp(this.url.concat("$").toLowerCase().replace(/\{\w+\}/g, '([\\w-]+)'));
    this._extractUrlParamsKey();
  }
  _createClass(Route, [{
    key: "_extractUrlParamsKey",
    value: function _extractUrlParamsKey() {
      var param,
          getParamRegex = new RegExp(/\{(\w+)\}/g);
      while (param = getParamRegex.exec(this.url)) {
        this.params[param[1]] = null;
      }
    }
  }, {
    key: "load",
    value: function load() {
      alert('not implemented');
    }
  }, {
    key: "_loadResource",
    value: function _loadResource(path) {
      return new Promise(function (resolve, reject) {
        if (!SystemJS) {
          console.error("we need systemjs  as a dependency to load modules pls setup systemjs for that");
          reject("systemjs is not defined");
        }
        SystemJS.import(path).then(function (output) {
          resolve(output);
        }).catch(function (e) {
          reject(e);
        });
      });
    }
  }]);
  return Route;
}();

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var ReactRoute =
function (_Route) {
  _inherits(ReactRoute, _Route);
  function ReactRoute(inputObj) {
    var _this;
    _classCallCheck$1(this, ReactRoute);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactRoute).call(this, inputObj));
    _defineProperty$1(_assertThisInitialized(_this), "componentPath", null);
    _this.componentPath = inputObj.reactComponentPath;
    return _this;
  }
  _createClass$1(ReactRoute, [{
    key: "load",
    value: function load() {
      var _this2 = this;
      return new Promise(function (resolve, reject) {
        _this2._loadResource(_this2.componentPath).then(function (component) {
          if (component.default) {
            resolve(component.default);
          } else {
            reject({
              message: 'the react component you want to load and initiate does not export defualt class to initiate. please add <export defualt ClassName> in your js file'
            });
          }
        }).catch(function (e) {
          reject(e);
        });
      });
    }
  }, {
    key: "loadge",
    value: function loadge(componentClass, containerDom) {
      return new Promise(function (resolve, reject) {
        ReactDOM.unmountComponentAtNode(containerDom);
        ReactDOM.render(React.createElement(componentClass, null), containerDom, function () {
          resolve(componentClass);
        });
      });
    }
  }]);
  return ReactRoute;
}(Route);

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var RouteFactory = function RouteFactory(inputObj) {
  _classCallCheck$2(this, RouteFactory);
  switch (inputObj.type) {
    case 'REACT':
      return new ReactRoute(inputObj);
      break;
    case undefined:
      return new Route(inputObj);
      break;
  }
};

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }
function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }
function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }
function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var instance = [];
var _loadStateKey = Symbol();
var Router =
function () {
  function Router(config) {
    var _this = this;
    _classCallCheck$3(this, Router);
    _defineProperty$2(this, "treeBaseRoutes", []);
    _defineProperty$2(this, "routes", []);
    _defineProperty$2(this, "errorRoutes", {});
    _defineProperty$2(this, "routeGroupsName", []);
    _defineProperty$2(this, "basePath", void 0);
    _defineProperty$2(this, "matchedRoute", {});
    _defineProperty$2(this, "componentsPathPrefix", '/');
    _defineProperty$2(this, "pageContainerTagId", void 0);
    _defineProperty$2(this, "isPageContainerMounted", false);
    _defineProperty$2(this, "params", {});
    _defineProperty$2(this, "currentPage", {
      routeDataObject: {},
      params: {},
      jsClass: null
    });
    _defineProperty$2(this, "pagesTitlePrefix", "");
    _defineProperty$2(this, "loadState", void 0);
    _defineProperty$2(this, "config", {
      instanceName: 'defualt',
      events: {
        onLoadStateChange: null
      }
    });
    if (_typeof$1(config) == "object") {
      Object.assign(this.config, config);
    }
    if (!instance[this.config.instanceName]) {
      instance[this.config.instanceName] = this;
    } else {
      return instance[this.config.instanceName];
    }
    this.treeBaseRoutes = this.config.routes;
    this.basePath = this.config.basePath;
    this.pageContainerTagId = this.config.pageContainerTagId;
    this.componentsPathPrefix = this.config.componentsPathPrefix;
    this.pagesTitlePrefix = this.config.pagesTitlePrefix;
    this._initLoadState();
    this._normalizeAndOptimazeRoutes();
    window.addEventListener('popstate', function (e) {
      return _this._onBrowserPopState(e);
    });
    return instance[this.config.instanceName];
  }
  _createClass$2(Router, [{
    key: "pageContainerDidMount",
    value: function pageContainerDidMount() {
      this.containerDom = document.getElementById(this.pageContainerTagId);
      if (!this.containerDom) {
        ExceptionHandler.newException("router can't find dom with " + this.pageContainerTagId + " ID maybe your html page is not ready yet");
        return false;
      } else {
        this.isPageContainerMounted = true;
      }
    }
  }, {
    key: "_initLoadState",
    value: function _initLoadState() {
      this[_loadStateKey] = null;
    }
  }, {
    key: "_callLoadStateChange",
    value: function _callLoadStateChange(oldValue, newValue) {
      if (this.config.events.onLoadStateChange) {
        this.config.events.onLoadStateChange(oldValue, newValue);
      }
    }
  }, {
    key: "_onBrowserPopState",
    value: function _onBrowserPopState(event) {
      var state = event.state;
      if (state && state.pushedByJBRouter) {
        this.loadPage(state.absolutePath, false);
      }
      return true;
    }
  }, {
    key: "_normalizeAndOptimazeRoutes",
    value: function _normalizeAndOptimazeRoutes() {
      var _this2 = this;
      var treeRouteTraverse = function treeRouteTraverse(routes, urlPrefix, settings) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
          for (var _iterator = routes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var rawRoute = _step.value;
            rawRoute['settings'] = Object.assign(rawRoute.settings || {}, settings);
            rawRoute['url'] = urlPrefix + rawRoute['url'];
            if (rawRoute.reactComponentPath) {
              rawRoute.reactComponentPath = _this2.componentsPathPrefix + rawRoute.reactComponentPath;
            }
            var route = new RouteFactory(rawRoute);
            _this2.routes.push(route);
            if (rawRoute.childRoutes) {
              treeRouteTraverse(rawRoute.childRoutes, route.url, route.settings);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };
      treeRouteTraverse(this.treeBaseRoutes, "", {});
      if (this.config.standardPageRoutes[404]) {
        this.errorRoutes[404] = new RouteFactory(this.config.standardPageRoutes[404]);
      }
      if (this.config.standardPageRoutes[424]) {
        this.errorRoutes[424] = new RouteFactory(this.config.standardPageRoutes[424]);
      }
    }
  }, {
    key: "_matchPathToOneRoute",
    value: function _matchPathToOneRoute(normalizedPath) {
      var match;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;
      try {
        for (var _iterator2 = this.routes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var route = _step2.value;
          if (normalizedPath == "/" && route.isRoot) {
            match = route;
            break;
          } else if (normalizedPath != "/" && !route.isRoot) {
            match = normalizedPath.match(route.regex);
            if (match) {
              var i = 1;
              for (var param in route.params) {
                route.params[param] = match[i++];
              }
              match = route;
              this.params = route.params;
              break;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      if (match) {
        this.matchedRoute = match;
      } else {
        this.matchedRoute = this.errorRoutes[404];
      }
      return this.matchedRoute;
    }
  }, {
    key: "loadPage",
    value: function loadPage(absolutePath, updateHistory) {
      if (!this.isPageContainerMounted) {
        ExceptionHandler.newException("router can`t load route and render it before 'pageContainerDidMount' function called");
        return false;
      }
      var normalizedPath = this._normalizePath(absolutePath);
      if (normalizedPath != -1) {
        var matchedRoute = this._matchPathToOneRoute(normalizedPath);
        if (matchedRoute) {
          var matchedRouteBasicValidity = true;
          if (!(matchedRoute.componentPath != null && matchedRoute.componentPath != undefined)) {
            matchedRouteBasicValidity = false;
            ExceptionHandler.newException(new Error(matchedRoute), "the matched Route we find dosent have any component path to load. /n please define component path so we can load and place it");
          }
          if (matchedRouteBasicValidity) {
            this._callLoadStateChange(this[_loadStateKey], 0);
            this[_loadStateKey] = 0;
            this._loadComponent(matchedRoute);
            this._setPageAttributes(matchedRoute.title, absolutePath, updateHistory);
            return matchedRoute;
          }
        } else {
          ExceptionHandler.newException(new Error(absolutePath), "آدرس وارد شده یافت نشد");
          return -1;
        }
      } else {
        ExceptionHandler.newException(new Error(absolutePath, "آدرس وارد شده یافت نشد"));
        return -1;
      }
    }
  }, {
    key: "_loadComponent",
    value: function _loadComponent(reactRoute) {
      var _this3 = this;
      reactRoute.load().then(function (componentClass) {
        _this3._onRouteLoadComplete(reactRoute, componentClass);
      }).catch(function (e) {
        _this3._onRouteLoadError(e, reactRoute);
      });
    }
  }, {
    key: "_setPageAttributes",
    value: function _setPageAttributes(title, absolutePath) {
      var updateHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      document.title = title + " | " + this.pagesTitlePrefix;
      if (updateHistory) {
        var historyState = {
          pushedByJBRouter: true,
          routeObject: this.matchedRoute,
          absolutePath: absolutePath
        };
        window.history.pushState(historyState, this.pagesTitlePrefix + title, absolutePath);
      }
    }
  }, {
    key: "_onRouteLoadComplete",
    value: function _onRouteLoadComplete(route, componentClass) {
      var _this4 = this;
      this._callLoadStateChange(this[_loadStateKey], 1);
      this[_loadStateKey] = 1;
      route.loadge(componentClass, this.containerDom).then(function (componentClass) {
        _this4._onRouteLoadgeComplete(componentClass);
      }).catch(function (e) {
        ExceptionHandler.newException(e, "we have exception in loadge the page. \n");
        _this4._onRouteLoadError(e, reactRoute);
      });
    }
  }, {
    key: "_onRouteLoadError",
    value: function _onRouteLoadError(e, route) {
      var _this5 = this;
      ExceptionHandler.newException(e, "در هنگام لود کامپوننت مشکلی پیش آمده است");
      if (!this.loadComponentTryCount) {
        this.loadComponentTryCount = 1;
      } else {
        this.loadComponentTryCount++;
      }
      if (this.loadComponentTryCount < 6) {
        setTimeout(function () {
          _this5._loadComponent(route);
        }, this.loadComponentTryCount * 2000);
      } else {
        this._loadComponent(this.errorRoutes[424]);
      }
    }
  }, {
    key: "_onRouteLoadgeComplete",
    value: function _onRouteLoadgeComplete(jsClass) {
      this.currentPage.routeDataObject = _objectSpread({}, this.matchedRoute);
      this.currentPage.jsClass = _objectSpread({}, jsClass);
      this.currentPage.params = _objectSpread({}, this.params);
      this._callLoadStateChange(this[_loadStateKey], 5);
      this[_loadStateKey] = 5;
    }
  }, {
    key: "_normalizePath",
    value: function _normalizePath(path) {
      var currentAbsolutePath = path.toLowerCase();
      var basePathStartIndex = currentAbsolutePath.indexOf(this.basePath.toLowerCase());
      if (basePathStartIndex == -1) {
        return -1;
      } else {
        var currentPath = currentAbsolutePath.substring(this.basePath.length, currentAbsolutePath.length);
        if (currentPath[currentPath.length - 1] == "/" && currentPath != "/") {
          currentPath = currentPath.substring(0, currentPath.length - 1);
        } else if (currentPath == "") {
          currentPath = "/";
        }
        if (currentPath.lastIndexOf('?') != -1) {
          currentPath = currentPath.slice(0, currentPath.lastIndexOf('?'));
        }
        return currentPath;
      }
    }
  }, {
    key: "loadState",
    get: function get() {
      return this[_loadStateKey];
    },
    set: function set(newValue) {
      if (newValue > 4 && newValue < 10) {
        this._callLoadStateChange(this[_loadStateKey], newValue);
        this[_loadStateKey] = newValue;
      } else {
        ExceptionHandler.newException({
          invalidValue: newValue
        }, "مقدار ست شده برای وضعیت لودینگ نمیتواند کمتر پنج و بیشتر از ده باشد \n");
      }
    }
  }]);
  return Router;
}();

module.exports = Router;
