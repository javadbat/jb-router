import ExceptionHandler from 'jb-modules/ExceptionHandler/ExceptionHandler';
import React from 'react';
import ReactDOM from 'react-dom';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Route =
/*#__PURE__*/
function () {
  function Route(inputObj) {
    _classCallCheck(this, Route);

    _defineProperty(this, "url", null);

    _defineProperty(this, "name", null);

    _defineProperty(this, "settings", {});

    _defineProperty(this, "title", "");

    _defineProperty(this, "isRoot", void 0);

    _defineProperty(this, "params", void 0);

    _defineProperty(this, "regex", void 0);

    //set params
    this.url = inputObj.url;
    this.name = inputObj.name;
    this.title = inputObj.title;
    this.settings = inputObj.settings; //TODO we must convert childs route before assign them 

    this.isRoot = this.url == "/" ? true : false;
    this.params = {}; //add $ symbol make regx to detect exact url (make it equal not include)

    this.regex = new RegExp(this.url.concat("$").toLowerCase().replace(/\{\w+\}/g, '([\\w-]+)')); //Get Param Of each Route

    this._extractUrlParamsKey();
  }

  _createClass(Route, [{
    key: "_extractUrlParamsKey",
    value: function _extractUrlParamsKey() {
      //define regex to extract param from url
      var param,
          getParamRegex = new RegExp(/\{(\w+)\}/g);

      while (param = getParamRegex.exec(this.url)) {
        // we define parameter but set them null 
        this.params[param[1]] = null;
      }
    }
  }, {
    key: "load",
    value: function load() {
      alert('not implemented');
    }
  }, {
    key: "_loadResource",
    value: function _loadResource(path) {
      return new Promise(function (resolve, reject) {
        SystemJS.import(path).then(function (output) {
          resolve(output);
        }).catch(function (e) {
          reject(e);
        });
      });
    }
  }]);

  return Route;
}();

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ReactRoute =
/*#__PURE__*/
function (_Route) {
  _inherits(ReactRoute, _Route);

  function ReactRoute(inputObj) {
    var _this;

    _classCallCheck$1(this, ReactRoute);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactRoute).call(this, inputObj));

    _defineProperty$1(_assertThisInitialized(_assertThisInitialized(_this)), "componentPath", null);

    _this.componentPath = inputObj.reactComponentPath;
    return _this;
  }

  _createClass$1(ReactRoute, [{
    key: "load",
    value: function load() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2._loadResource(_this2.componentPath).then(function (component) {
          if (component.default) {
            resolve(component.default);
          } else {
            reject({
              message: 'the react component you want to load and initiate does not export defualt class to initiate. please add <export defualt ClassName> in your js file'
            });
          }
        }).catch(function (e) {
          reject(e);
        });
      });
    }
  }, {
    key: "loadge",
    value: function loadge(componentClass, containerDom) {
      return new Promise(function (resolve, reject) {
        //Remove Current Component From pageContainer
        ReactDOM.unmountComponentAtNode(containerDom); //initiate react component to its place in page

        ReactDOM.render(React.createElement(componentClass, null), containerDom, function () {
          resolve(componentClass);
        });
      });
    }
  }]);

  return ReactRoute;
}(Route);

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RouteFactory = function RouteFactory(inputObj) {
  _classCallCheck$2(this, RouteFactory);

  switch (inputObj.type) {
    case 'REACT':
      return new ReactRoute(inputObj);
      break;

    case undefined:
      return new Route(inputObj);
      break;
  }
};

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }

function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var instance = []; //to make loadSate private cycle

var _loadStateKey = Symbol();

var Router =
/*#__PURE__*/
function () {
  //Contaien All Tree Base Routes

  /**
   * Normalized Routes, Flat
   * @type {Array of Obejcts}
   */

  /**
   * Route Groups Name
   */

  /**
   * Base Path
   */

  /**
   * Match Route Object
   */

  /**
   * Components Path Prefix
   */

  /**
   * HTML Element that any Component Will be Loaded In
   */

  /**
   * Router is able to Load Components When Page container
   * is Mounted To DOM Actually
   * So when Page Container doesn't Mounted, loadPage Method Will Prevent
   * @type {Boolean}
   */

  /**
   * Contains Path Parameters to use in page
   */

  /**
   * the current page is the page that already loaded and initiated
   */
  // to find is page under load 

  /*
  * 0 is page under load
  * -1 is fail in load
  * null for no route is loaded yet in this instance
  * 1 is page loaded but not initaited
  * 2,3,4 is reserved for future use in between for pure html css js view 
  * 5 is page initated and router is done completely done
  * 6-9 is used for inner page ajax loading and initiating level for page developer to use
  * 10 mean completly done and everything is ready 
  * @type {number}
  * 0-5 state cant be change by user and user is prevented to change state if its before 5 or change it to less than 5 
  */

  /**
   * Configuration
   */
  function Router(config) {
    var _this = this;

    _classCallCheck$3(this, Router);

    _defineProperty$2(this, "treeBaseRoutes", []);

    _defineProperty$2(this, "routes", []);

    _defineProperty$2(this, "errorRoutes", {});

    _defineProperty$2(this, "routeGroupsName", []);

    _defineProperty$2(this, "basePath", void 0);

    _defineProperty$2(this, "matchedRoute", {});

    _defineProperty$2(this, "componentsPathPrefix", '/');

    _defineProperty$2(this, "pageContainerTagId", void 0);

    _defineProperty$2(this, "isPageContainerMounted", false);

    _defineProperty$2(this, "params", {});

    _defineProperty$2(this, "currentPage", {
      routeDataObject: {},
      //the url params we want to pass
      params: {},
      //the es6,7 class of page that loaded
      jsClass: null
      /**
       * Pages Title Prefix
       */

    });

    _defineProperty$2(this, "pagesTitlePrefix", "");

    _defineProperty$2(this, "loadState", void 0);

    _defineProperty$2(this, "config", {
      //we can have multiple instance of routes and get them by name
      instanceName: 'defualt',
      events: {
        onLoadStateChange: null
      }
    });

    if (_typeof$1(config) == "object") {
      Object.assign(this.config, config);
    }

    if (!instance[this.config.instanceName]) {
      instance[this.config.instanceName] = this;
    } else {
      //if we created the instance with the same name before it will return prev one
      return instance[this.config.instanceName];
    }

    this.treeBaseRoutes = this.config.routes;
    this.basePath = this.config.basePath;
    this.pageContainerTagId = this.config.pageContainerTagId;
    this.componentsPathPrefix = this.config.componentsPathPrefix;
    this.pagesTitlePrefix = this.config.pagesTitlePrefix; //to keep plugin current load state

    this._initLoadState(); //convert user route config to router standard format


    this._normalizeAndOptimazeRoutes(); //listen to browser state change (back , refresh , forward)


    window.addEventListener('popstate', function (e) {
      return _this._onBrowserPopState(e);
    });
    return instance[this.config.instanceName];
  }
  /**
   * This method will call when Page Container is Mounted
   */


  _createClass$2(Router, [{
    key: "pageContainerDidMount",
    value: function pageContainerDidMount() {
      //Get Page Container Element
      this.containerDom = document.getElementById(this.pageContainerTagId);

      if (!this.containerDom) {
        ExceptionHandler.newException("router can't find dom with " + this.pageContainerTagId + " ID");
      }

      this.isPageContainerMounted = true;
    }
  }, {
    key: "_initLoadState",
    value: function _initLoadState() {
      this[_loadStateKey] = null;
    }
  }, {
    key: "_callLoadStateChange",
    value: function _callLoadStateChange(oldValue, newValue) {
      if (this.config.events.onLoadStateChange) {
        this.config.events.onLoadStateChange(oldValue, newValue);
      }
    }
  }, {
    key: "_onBrowserPopState",
    value: function _onBrowserPopState(event) {
      //on browser back or forward btn clicked
      var state = event.state;

      if (state && state.pushedByJBRouter) {
        this.loadPage(state.absolutePath, false);
      }

      return true;
    }
    /**
     ** Optimize And Normalized Routes
     ** Add Computed Param Of Path
     ** Add Route Regex For Faster Matching
     */

  }, {
    key: "_normalizeAndOptimazeRoutes",
    value: function _normalizeAndOptimazeRoutes() {
      var _this2 = this;

      // transpile and convert tree data structure of config data  to list of Route object
      var treeRouteTraverse = function treeRouteTraverse(routes, urlPrefix, settings) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = routes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var rawRoute = _step.value;
            //Add Route Group Name
            rawRoute['settings'] = Object.assign(rawRoute.settings || {}, settings); //Add UrlPrefix

            rawRoute['url'] = urlPrefix + rawRoute['url'];

            if (rawRoute.reactComponentPath) {
              rawRoute.reactComponentPath = _this2.componentsPathPrefix + rawRoute.reactComponentPath;
            } //create Route object


            var route = new RouteFactory(rawRoute); //Add To Routes

            _this2.routes.push(route);

            if (rawRoute.childRoutes) {
              treeRouteTraverse(rawRoute.childRoutes, route.url, route.settings);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }; //standard page routes and convert to Route class standard object


      treeRouteTraverse(this.treeBaseRoutes, "", {}); //standard erroPages and convert to Route class standard object

      this.errorRoutes[404] = new RouteFactory(this.config.standardPageRoutes[404]);
      this.errorRoutes[424] = new RouteFactory(this.config.standardPageRoutes[424]);
    }
    /**
     ** Normalize Path
     ** /Panel/StoreConfirmation/ => /storeconfirmation
     */

    /**
     * Match Current Path To Route Path
     * @return { Matched Route }
     */

  }, {
    key: "_matchPathToOneRoute",
    value: function _matchPathToOneRoute(normalizedPath) {
      var match; //Iterate Through All Routes To

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.routes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var route = _step2.value;

          //Handle Root Path
          if (normalizedPath == "/" && route.isRoot) {
            match = route;
            break; //Check Other routes
          } else if (normalizedPath != "/" && !route.isRoot) {
            //If Current Route Matched
            match = normalizedPath.match(route.regex);

            if (match) {
              var i = 1; //extract Params

              for (var param in route.params) {
                route.params[param] = match[i++];
              }

              match = route; //Assign Route Parameter

              this.params = route.params;
              break;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (match) {
        this.matchedRoute = match;
      } else {
        this.matchedRoute = this.errorRoutes[404];
      }

      return this.matchedRoute;
    }
    /**
     ** Load Page Base On Path
     */

  }, {
    key: "loadPage",
    value: function loadPage(absolutePath, updateHistory) {
      //update history is false when we dont want t update browserHistory on rout like when browser back button clicked
      //If Page Container does'nt Mounted
      if (!this.isPageContainerMounted) {
        return false;
      } //Remove Base Path From Absolute Path


      var normalizedPath = this._normalizePath(absolutePath);

      if (normalizedPath != -1) {
        var matchedRoute = this._matchPathToOneRoute(normalizedPath);

        if (matchedRoute) {
          //check matched route valid state to load
          var matchedRouteBasicValidity = true;

          if (!(matchedRoute.componentPath != null && matchedRoute.componentPath != undefined)) {
            //if we dont have react component path in data
            matchedRouteBasicValidity = false;
            ExceptionHandler.newException(new Error(matchedRoute), "در هنگام پیدا کردن آبجکت مسیر دهی مسیر مشخص شده حاوی آدرس کامپوننت نمیباشد");
          }

          if (matchedRouteBasicValidity) {
            this._callLoadStateChange(this[_loadStateKey], 0);

            this[_loadStateKey] = 0;

            this._loadComponent(matchedRoute);

            this._setPageAttributes(matchedRoute.title, absolutePath, updateHistory);

            return matchedRoute;
          }
        } else {
          ExceptionHandler.newException(new Error(absolutePath), "آدرس وارد شده یافت نشد");
        }
      } else {
        ExceptionHandler.newException(new Error(absolutePath, "آدرس وارد شده یافت نشد"));
      }
    }
  }, {
    key: "_loadComponent",
    value: function _loadComponent(reactRoute) {
      var _this3 = this;

      //Get Components
      reactRoute.load().then(function (componentClass) {
        _this3._onRouteLoadComplete(reactRoute, componentClass);
      }).catch(function (e) {
        _this3._onRouteLoadError(e, reactRoute);
      });
    }
    /**
     ** Set Page Attr such As Page Title and Url
     ** HTML5 History
     */

  }, {
    key: "_setPageAttributes",
    value: function _setPageAttributes(title, absolutePath) {
      var updateHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      //Set Document Title
      document.title = title + " | " + this.pagesTitlePrefix; //Update URL
      //fill route state to manage events
      //in case of popstate event we dont update history

      if (updateHistory) {
        var historyState = {
          pushedByJBRouter: true,
          routeObject: this.matchedRoute,
          absolutePath: absolutePath
        };
        window.history.pushState(historyState, this.pagesTitlePrefix + title, absolutePath);
      }
    }
  }, {
    key: "_onRouteLoadComplete",
    value: function _onRouteLoadComplete(route, componentClass) {
      var _this4 = this;

      this._callLoadStateChange(this[_loadStateKey], 1);

      this[_loadStateKey] = 1;
      route.loadge(componentClass, this.containerDom).then(function (componentClass) {
        _this4._onRouteLoadgeComplete(componentClass);
      });
    }
  }, {
    key: "_onRouteLoadError",
    value: function _onRouteLoadError(e, route) {
      var _this5 = this;

      ExceptionHandler.newException(e, "در هنگام لود کامپوننت مشکلی پیش آمده است");

      if (!this.loadComponentTryCount) {
        this.loadComponentTryCount = 1;
      } else {
        this.loadComponentTryCount++;
      }

      if (this.loadComponentTryCount < 6) {
        //try to load it again 
        setTimeout(function () {
          _this5._loadComponent(route);
        }, this.loadComponentTryCount * 2000);
      } else {
        //when we disapoint to try to load again
        //we show 424 error page
        this._loadComponent(this.errorRoutes[424]);
      }
    }
  }, {
    key: "_onRouteLoadgeComplete",
    value: function _onRouteLoadgeComplete(jsClass) {
      //when page loaded successffully and placed successfully on page and rendered
      // {...obect} make clone of orginal object
      this.currentPage.routeDataObject = _objectSpread({}, this.matchedRoute);
      this.currentPage.jsClass = _objectSpread({}, jsClass);
      this.currentPage.params = _objectSpread({}, this.params);

      this._callLoadStateChange(this[_loadStateKey], 5);

      this[_loadStateKey] = 5;
    }
    /**
    ** Absolute Path:   /Panel/storeconfirmation
    ** Normalized Path: /storeconfirmation
    */

  }, {
    key: "_normalizePath",
    value: function _normalizePath(path) {
      var currentAbsolutePath = path.toLowerCase();
      var basePathStartIndex = currentAbsolutePath.indexOf(this.basePath.toLowerCase()); //if We Dont Have Base Path In Absolute Path

      if (basePathStartIndex == -1) {
        return -1;
      } else {
        //Handle Slash At the Of URL
        var currentPath = currentAbsolutePath.substring(this.basePath.length, currentAbsolutePath.length); //Remove Trailing Slash From end Of Path

        if (currentPath[currentPath.length - 1] == "/" && currentPath != "/") {
          currentPath = currentPath.substring(0, currentPath.length - 1);
        } else if (currentPath == "") {
          currentPath = "/";
        } //remove page parameter from path 
        //this parameter dont seprate our route but just use in page for example search and filter query ro page index of table in pages


        if (currentPath.lastIndexOf('?') != -1) {
          currentPath = currentPath.slice(0, currentPath.lastIndexOf('?'));
        }

        return currentPath;
      }
    }
  }, {
    key: "loadState",
    get: function get() {
      return this[_loadStateKey];
    },
    set: function set(newValue) {
      if (newValue > 4 && newValue < 10) {
        this._callLoadStateChange(this[_loadStateKey], newValue);

        this[_loadStateKey] = newValue;
      } else {
        ExceptionHandler.newException({
          invalidValue: newValue
        }, "مقدار ست شده برای وضعیت لودینگ نمیتواند کمتر پنج و بیشتر از ده باشد \n");
      }
    }
  }]);

  return Router;
}();

export default Router;
